<!DOCTYPE html>
<html>
<head>
  <title></title>
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,500;0,600;0,700;0,800;0,900;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/@mdi/font@4.x/css/materialdesignicons.min.css" rel="stylesheet">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
  <script src="https://cdn.jsdelivr.net/npm/http-vue-loader@1.4.2/src/httpVueLoader.min.js"></script>
  <style>
    [v-cloak] { display: none; }
    #app {
      display: grid;
      align-items: stretch;
      grid-template-columns: 1fr;
      grid-template-rows: auto 1fr auto;
      grid-template-areas: 
        "header"
        "content"
        "footer";
      height: 100vh;
      width: 100vw;
      position: absolute;
    }
    .header {
      grid-area: header;
    }
    .content {
      grid-area: content;
      overflow-y: auto;
      height: 100%;
    }
    .footer {
      grid-area: footer;
    }
    .visible {
      visibility: visible;
      opacity: 1;
      transition: opacity 0.5s linear;
    }
    .hidden {
      visibility: hidden;
      opacity: 0;
      /* transition: opacity 0.5s linear; */
      /* transition: visibility 0s 1s, opacity 1s linear; */
    }
  </style>   

    <!-- Used for deep linking of Single Page Apps when hosted with GitHub Pages -->
    <script type="text/javascript">
      // Single Page Apps for GitHub Pages
      // https://github.com/rafrex/spa-github-pages
      // Copyright (c) 2016 Rafael Pedicini, licensed under the MIT License
      (function(l) {
        if (l.search) {
          let q = {}
          l.search.slice(1).split('&').forEach(function(v) {
            let a = v.split('=')
            q[a[0]] = a.slice(1).join('=').replace(/~and~/g, '&')
          })
          if (q.p !== undefined) {
            window.history.replaceState(null, null, l.pathname.slice(0, -1) + (q.p || '') + (q.q ? ('?' + q.q) : '') + l.hash)
          }
        }
      }(window.location))
    </script>
    <!-- End Single Page Apps for GitHub Pages -->

</head>
<body>
  <div id="app">
    
    <div class="header">
      <component v-if="essayConfig" :is="essayConfig.layout === 'index' ? 'indexHeader' : 'essayHeader'"
        :height="400"
        :essay-config="essayConfig"
        :site-config="context"
        :is-authenticated="isAuthenticated"
        :read-only="readOnly"
        :href="href"
        :app-version="appVersion"
        :content-ref="ref"
        @menu-item-clicked="menuItemClicked"
        @logout="logout"
        @view-markdown="viewMarkdown"
        @edit-markdown="editMarkdown"
        @goto-github="gotoGithub"
        @open-docs-site="openDocsSite"
      ></component>
    </div>

    <div id="content" v-html="html" class="content hidden"></div>

    <div class="footer">
      <component is="siteFooter" :site-config="context"></component>
    </div>
  
  </div>

  <script>window.context = null;</script>
  <script src="/static/js/visual-essays.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vue@2.x/dist/vue.js"></script>
  <script src="https://kit.fontawesome.com/19541ddce8.js" crossorigin="anonymous"></script>

<script>

const defaultGhAcct = 'jstor-labs'
const defaultGhRepo = 'visual-essays'
const defaultGhRef = 'main'
const isGithubCommitHash = RegExp(`[0-9a-f]+$`)

new Promise(function(resolve, reject) {
  function waitForContext() {
    if (window.context) {
      resolve(window.context)
    } else {
      setTimeout(waitForContext, 250)
    }
  }
  waitForContext()
})
.then(context => {
      console.log('context', context)
      window.app = new Vue({
        el: '#app',
        components: {
          'indexHeader': httpVueLoader(context.components.indexHeader && context.components.indexHeader.src),
          'essayHeader': httpVueLoader(context.components.essayHeader && context.components.essayHeader.src),
          'siteFooter': httpVueLoader(context.components.siteFooter && context.components.siteFooter.src)        
        },
        data: () => ({
          context,
          html: undefined,
          isLoaded: false,
          essayConfig: null,
          essayCache: {},
          appVersion: 'APP_VERSION',
          current: undefined,
          externalWindow: undefined,
          jwt: context.jwt,
          href: undefined,
          siteInfo: {}
        }),
        computed: {
          isAuthenticated() { return this.jwt !== null && this.jwt !== undefined },
          readOnly() { return this.context.qargs.readonly },
          ref() { return context.qargs && context.qargs.ref ? context.qargs.ref : this.siteInfo.ref},
          refQueryArg() { return this.ref && this.ref !== this.siteInfo.ref ? `?ref=${this.ref}` : '' }
        },
        mounted() {
          window.onpopstate = (e) => { this.loadEssay(e.state.file, true) }
          this.getSiteInfo().then(siteInfo => {
            console.log(siteInfo)
            this.siteInfo = siteInfo
            this.loadEssay(window.location.pathname)
          })
          
        },
        methods: {
          async getSiteInfo() {
            const resp = await fetch(`/site-info?href=${window.location.href}`)
            if (resp.ok) {
              return await resp.json()
            }
          },
          /*
          async getSiteInfo() {
            let hostname = window.location.hostname
            let siteInfo = {
              ghpSite: false,
              baseurl: '',
              acct: defaultGhAcct,
              repo: defaultGhRepo,
              ref: defaultGhRef,
              defaultBranch: null,
              editBranch: null
            }
            let siteConfigUrl
            console.log(`getSiteInfo: hostname=${hostname}`)
            let configResp
            if (hostname.indexOf('.github.io') > 0) { // Github Pages site
              siteInfo = {...siteInfo, ...{
                ghpSite: true,
                acct:    hostname.slice(0, hostname.length-10),
                repo:    window.location.pathname.split('/')[1],
                baseurl: `/${siteInfo.repo}`
              }}
              const resp = await fetch(`https://api.github.com/repos/${siteInfo.acct}/${siteInfo.repo}`)
              let repoInfo = await resp.json()
              siteInfo.defaultBranch = repoInfo.default_branch
              siteInfo.ref = siteInfo.defaultBranch
            } else if (hostname === 'localhost' || hostname.indexOf('visual-essays.app') > 0 || hostname.indexOf('gitpod.io') > 0) {
              const pathElems = window.location.pathname.split('/').filter(pathElem => pathElem !== '')
              if (pathElems.length >= 2) {
                const resp = await fetch(`https://api.github.com/repos/${pathElems[0]}/${pathElems[1]}`)
                if (resp.ok) {
                  let repoInfo = await resp.json()
                  siteInfo = {...siteInfo, ...{
                    acct: pathElems[0],
                    repo: pathElems[1], 
                    defaultBranch: repoInfo.default_branch,
                    ref: repoInfo.default_branch,
                    baseurl: `/${pathElems[0]}/${pathElems[1]}`
                  }}
                }
              }
            } else {
              siteConfigUrl = `${window.location.origin}/config.json`
            }
            siteConfigUrl = siteConfigUrl || `https://raw.githubusercontent.com/${siteInfo.acct}/${siteInfo.repo}/${siteInfo.ref}/config.json`
            configResp = await fetch(siteConfigUrl)
            if (configResp.ok) {
              let siteConfig = await configResp.json()
              siteInfo = {...siteInfo, ...{
                acct: siteConfig.content && siteConfig.content.acct ? siteConfig.content.acct : siteConfig.acct || siteInfo.acct,
                repo: siteConfig.content && siteConfig.content.repo ? siteConfig.content.repo : siteConfig.repo || siteInfo.repo,
                ref:  siteConfig.content && siteConfig.content.ref ? siteConfig.content.ref : siteConfig.ref || siteInfo.ref
              }}
            }
            if (!siteInfo.defaultBranch) {
              const resp = await fetch(`https://api.github.com/repos/${siteInfo.acct}/${siteInfo.repo}`)
              if (resp.ok) {
                let repoInfo = await resp.json()
                siteInfo.defaultBranch = repoInfo.default_branch
              }
            }
            if (siteInfo.ref.length === 7 && isGithubCommitHash.test(siteInfo.ref)) {
              const resp = await fetch(
                `https://api.github.com/repos/${siteInfo.acct}/${siteInfo.repo}/commits/${siteInfo.ref}/branches-where-head`, {
                headers: { Accept: 'application/vnd.github.groot-preview+json'}
              })
              if (resp.ok) {
                let commitInfo = await resp.json()
                siteInfo.editBranch = commitInfo[0].name
              }
            } else {
              siteInfo.editBranch = siteInfo.ref
            }
            return siteInfo
          },
          */
          async isGithubPagesSite (hostname) {
            hostname = hostname || window.location.hostname
            /*
            let resp = await fetch(`https://dns.google/resolve?name=${hostname}`)
            if (resp.ok) {
              let dnsInfo = await resp.json()
              return dnsInfo.Answer
                ? dnsInfo.Answer.find(rec => rec.data.indexOf('.github.io') > 0 ) !== undefined
                : false
            }
            return false
            */
            return hostname.indexOf('.github.io' > 0)
          },
          logout() {
            this.jwt = undefined
            window.localStorage.removeItem('ghcreds')
          },
          menuItemClicked(path) {
            path = `${this.siteInfo.baseurl}${path}`
            if (path !== this.current) this.loadEssay(path)
          },
          async fetchRetry (url, retries=3, backoff=300, lastError=null) {
            const retryCodes = [408, 500, 502, 503, 504, 522, 524]
            const delay = ms => new Promise(resolve => setTimeout(resolve, ms))
            if (retries === 0 ) throw new Error(lastError)
            try {
              const resp = await fetch(url)
              if (retryCodes.includes(resp.status)) throw new Error(resp)
              return resp
            } catch (e) {
              await delay(backoff)
              return this.fetchRetry(url, retries-1, backoff * 2, lastError)
            }
          },
          cachingFetch(path) {
            let url = `/essay${path}`
            console.log(`fetch=${url}`)
            if (!this.essayCache[url]) {
              this.essayCache[url] = this.fetchRetry(url).then(resp => resp.ok ? resp.text() : null)
            }
            return this.essayCache[url]
          },
          loadEssay(path, replace, retries) {
            path = `${path}${this.refQueryArg}`
            this.cachingFetch(path)
            .then(html => {
              browserPath = path.replace(/\.md$/, '')
              if (replace) {
                history.replaceState({file: path || ''}, '', browserPath)
              } else {
                history.pushState({file: path || ''}, '', browserPath)
              }
              this.href = window.location.href
              this.html = html
              this.current = path
              document.getElementById('content').classList.remove('visible')
              document.getElementById('content').classList.add('hidden')
              this.$nextTick(() => {
                const essayElem = document.getElementById('essay')
                if (essayElem) window._essay = essayElem.dataset.name
                const essayFname = essayElem ? essayElem.dataset.name.split('/').pop() : null
                console.log(`essayFname=${essayFname}`)
                if (essayFname === 'README' || essayFname === 'index') {
                    console.log(window.location.pathname)
                    if (window.location.pathname.length === 0 || window.location.pathname[window.location.pathname.length-1] !== '/') {
                      let browserPath = `${window.location.pathname}/${this.refQueryArg}`
                      window.history.replaceState({file: path || ''}, '', browserPath)
                    }
                }
              })
            })
          },
          viewMarkdown() {
            this.openWindow(`/markdown-viewer/${this.siteInfo.acct}/${this.siteInfo.repo}/${this.ref}${window._essay}.md`)
          },
          editMarkdown(editor) {
            this.openWindow(editor == 'custom'
              ? `https://editor.visual-essays.app/${this.siteInfo.acct}/${this.siteInfo.repo}${window._essay}.md`
              : `https://github.com/${this.siteInfo.acct}/${this.siteInfo.repo}/edit/${this.siteInfo.editBranch}${window._essay}.md`
            ) 
          },
          gotoGithub() {
            this.openWindow(`https://github.com/${this.siteInfo.acct}/${this.siteInfo.repo}/tree/${this.ref}`, null)
          },
          openDocsSite(editor) {
            this.openWindow(`https://docs.visual-essays.app?readonly`, `toolbar=yes,location=yes,left=0,top=0,width=1000,height=1200,scrollbars=yes,status=yes`)
          },
          openWindow(url, options) {
            if (this.externalWindow) { this.externalWindow.close() }
            if (options === undefined) options = 'toolbar=yes,location=yes,left=0,top=0,width=1000,height=1200,scrollbars=yes,status=yes'
            this.externalWindow = window.open(url, '_blank', options)
          },
          convertLinks() {
            // convert links
            const essayElem = document.getElementById('essay')
            if (essayElem) {
              essayElem.querySelectorAll('a').forEach(link => {
                console.log(link.href)
                if (!link.href || link.href.indexOf(window.location.host) > 0 || link.href.indexOf('/help#') > 0 ) {
                  let target = link.dataset.target
                  if (!target) { 
                    const parsedUrl = parseUrl(link.href)
                    if (parsedUrl.hash === '' ) {
                      //const pathElems = parsedUrl.pathname.split('/').filter(pathElem => pathElem !== '')
                      if (this.siteInfo.baseurl && parsedUrl.pathname.indexOf(this.siteInfo.baseurl) !== 0) {
                        target = `${this.siteInfo.baseurl}${parsedUrl.pathname}`
                      } else {
                        target = parsedUrl.pathname
                      }
                    } else {
                      target = parsedUrl.hash.split('?')[0]
                    }
                  }
                  link.addEventListener('click', (e) => {
                    console.log('click', e, target)
                    if (target[0] === '#') {
                      document.querySelector(target).scrollIntoView({block:'center'})
                    } else {
                      this.loadEssay(target)
                    }
                  })
                  link.removeAttribute('href')
                  link.setAttribute('data-target', target)
                } else {
                  link.innerHTML += '<sup><i class="fal fa-external-link-alt" style="margin-left:4px;font-size:0.8em;color:blue;"></i></sup>'
                  link.setAttribute('target', '_blank')
                }
              })
            }
          },
          waitForEssayReady() {
            const essayElem = document.getElementById('essay')
            if (essayElem) {
              this.convertLinks()
              document.getElementById('content').classList.add('visible')
              document.getElementById('content').classList.remove('hidden')
            } else {
              setTimeout(this.waitForEssayReady, 10)
            }
          }
        },
        watch: {
          isLoaded() {    
            if (this.isLoaded) {
              this.isLoaded = false
              this.$nextTick(() => this.waitForEssayReady())
            }
          }
        }
      })
    })
    function parseUrl (href) {
      const match = href.match(/^(https?)\:\/\/(([^:\/?#]*)(?:\:([0-9]+))?)(\/[^?#]*)(\?[^#]*|)(#.*|)$/)
      return match && {protocol: match[1], host: match[2], hostname: match[3], origin: `${match[1]}://${match[2]}`, port: match[4], pathname: match[5], search: match[6], hash: match[7]}
    }
  </script>
</body>
</html>
